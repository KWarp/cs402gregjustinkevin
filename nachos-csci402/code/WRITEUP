Title:  Writeup for Project 2, Fall 2010
Date:  10/10/2010
Group Number 28 :

Name            	                  Email                            Student ID
Greg Lieberman         greglieb@usc.edu            6424286089
Justin Lewis               jdl@usc.edu                     5771862417
Kevin Greene            kgreene@usc.edu             7671772747

=================
Running the code:
=================
	
In the userprog directory:
nachos -x ../test/[executable name]

Running the restaurant simulation:
	nachos -x ../test/simulation
By default, the simulation runs with 3 OrderTakers, 3 Waiters, and 20 Customers

Executable Names for Tests in the test directory:
testfork
testexec
testsynchmanager

=================
I. Requirements:
=================

Part 1 - Implement System Calls and Exception Handling
-- Implement the Syscalls Fork, Exec, Exit, Yield
-- Turn the following into Syscalls: Acquire, Release, Signal, Broadcast, Wait
	These take integers relative to the kernel space as arguments.
-- Also implement CreateLock, DestroyLock, CreateCondition, and DestroyCondition. 
These return integers relative to kernel space, not pointers.
-- The Exit Syscall should ensure that Thread::Finish is called, except when it is the last thread.
Then it should call Halt.
-- The Exec and Fork Syscall requires implementation of creating address spaces and binding them to threads. A process table is recommended.
-- Under no circumstances should the use (or misuse) of System calls crash the Operating System.
-- Write a test suite that shows:
	Your Syscalls function correctly
	Your Syscalls deal with bad user input gracefully, and print informative errors
	Your Syscalls never crash Nachos
-- Test suite executables should be user programs
-- Document your test suite
-- Console output should also be synchronized


Part 2 - Implement Multiprogramming
-- Implement allocation of physical memory frames so that multiple programs can be loaded into memory at once.
-- Find a way to copy data to/from the kernel to the user’s address space. The addresses that the user and the kernel see must be different.
-- Implement Exec and Fork
-- Exec creates a new address space and starts a single thread
-- Write a test suite that shows the Exec and Fork behave correctly
Deal with bad input gracefully
Never crash Nachos
 
Part 3
-- Implement part 2 of Project 1 as a set of multithreaded Nachos user programs
-- This is to be a user C program
-- It must use the Lock and Condition Syscalls you implemented
-- It must also create all it’s threads with Fork
-- Create a second Restaurant Simulation with the Exec Syscall
-- Provide a test suite to show that the implementation is correct


=================
II. Assumptions:
=================

	- Users will never use more than 10,000 locks, or 40,000 condition variables.
	- Redfishes are red.
	- Users are evil and/or retarded.
	- Pi , one and e are consistent.
- Assumed that executables will not require more than NumPhysPages.
- Unlimited physical memory.  
- A tautology is a tautology
- Assumed that stack spaces are not reallocated.
	

=================
III. Design:
=================

Overview:
- To implement the System Calls for Locks, and Conditions, we created a class called SynchManager to manage Creation and Destruction of Locks, and access to the kernel Lock table and Condition table. We did this to encapsulate the synchronization logic.
- To implement System Calls for Fork, Exec, Exit, and Yield we built on top of the existing Nachos code base.
- There is a more detailed version of the design below in the implementation part.  We put it here so that it would be better organized.

Process:

	We did shit, then we wrote about it (that's this part, right here -->).  Occasionally we took breaks to watch popular TV shows.  Most of the time we were severely distracted.  Honestly we started on Friday night, we proceeded to accomplish almost nothing before succumbing completely to Justin's impressive list of illegally downloaded movies.  Actually almost all of the code was already designed and organized for us.  When we built the first project we built it having already known what the following two projects would be, hence we only had to build memory architectures for the OS level code.  We had even made the locks, condition variables, and threads accessible as if they were system calls, so we did not have to change the simulation file at all.  Saturday and Sunday night were spent avoiding the homework in favor of more entertaining things.  We were largely frustrated over a few minor glitches for most of the time, but relaxing by playing with fridge magnets cleared our ram and our fresh minds solved the problems quickly.

Since we did not have much code to add, we all sat in a room and mashed on the keyboard in a synchronized ballet of code.  The performance was beautiful.  Never before had an instance of extreme programing been so amazingly choreographed.  Furthermore each of the actors was at his prime.  They carried their characters through the stage and into the text with great vivacity and in some cases the appropriate amount of spontaneity.   It would be hard to say that any out shined the others as the glare from their pearly eyes left everyone in the audience both stunned and blinded.  Also Greg was wearing his Uni-code shirt, and thought that it would bring us great luck.

IV. Implementation:

Part 1.)
To create a lock:
int CreateLock():
In the OS code, create a Lock object and store it in an array that is only available in Kernel Space. Return an int index into that array of Locks for the newly created Lock.
Example use: int lock = CreateLock();
Equivalent to: Lock* lock = new Lock("stewardBusyLock");

To acquire a lock:
void Acquire(int lock):
Takes an index to kernel lock array.
Example use:
int lock= CreateLock();
Acquire(lock);
Equivalent to:
Lock* lock= new Lock("newlock");
lock->Acquire();
        
To release a lock:
void Release(int lock):
Takes an index to kernel lock array.
Example use:
int lock= CreateLock();
Acquire(lock);
Release(lock);
Equivalent to:
Lock* lock= new Lock("newlock");
lock->Acquire();
lock->Release();
        
To destroy a lock:
void DestroyLock(int lock); //Takes an index to kernel lock array. Returns error code.
Example use:
int lock= CreateLock();
DestroyLock(lock);
Equivalent to:
Lock* lock= new Lock("newlock");
delete lock;

To create a CV:
int CreateCondition():
Similar to CreateLock(). Returns an int that is an index to the CV array handled by the kernel code.
Example use: int cv = CreateCV();
Equivalent to: Condition* cv = new Condition("newcv");

To Signal a CV:
void Signal(int cv, int lock):
Takes an int that indexes into the kernel CV array and an int that indexes into the kernel lock array. Wakes up one waiting thread.
Example use:
int lock = CreateLock();
Acquire(lock);
int cv = CreateCV();
Signal(cv, lock);
Equivalent to:
Lock* lock= new Lock("newlock");
lock->Acquire();
Condition* cv= new Condition("newcv");
cv->Signal(lock);

To Broadcast a CV:
void Broadcast(int cv, int lock):
Takes an int that indexes into the kernel CV array and an int that indexes into the kernel lock array. Signals in a loop until there are no more waiting threads.
Example use:
int lock = CreateLock();
Acquire(lock);
int cv = CreateCV();
Broadcast(cv, lock);
Equivalent to:
Lock* lock = new Lock("newlock");
lock->Acquire();
Condition* cv = new Condition("newcv");
cv->Broadcast(lock);
        
To Wait a CV:
void Wait(int cv, int lock)
Takes an int that indexes into the kernel CV array and an int that indexes into the kernel lock array. Puts the currentThread to sleep until another thread signals cv.
Example use:
int lock = CreateLock();
Acquire(lock);
int cv = CreateCV();
Wait(cv, lock);
Equivalent to:
Lock* lock = new Lock("newlock");
lock->Acquire();
Condition* cv = new Condition("newcv");
cv->Wait(lock);
        
To destroy a CV:
void DestroyCondition(int cv):
Takes an index to kernel CV array. Deletes the item indexed by cv in the kernel CV array.
Example use:
int cv = CreateCondition();
DeleteCondition(cv);
Equivalent to:
		Condition* cv = new Condition(“newcv”);
		delete cv;

To Yield:
void Yield()
Takes nothing, returns nothing. Simply calls currentThead->Yield();.
Example use:
Yield();
Equivalent to:
		currentThread->Yield();

To Fork a thread:
void Fork_Syscall(VoidFunctionPtr func)
	if (function pointer is not bad)
		-create a new thread
		-allocate stack for that thread in the current address space and store the virtual address of the top of the stack
		-add entry into process table for this newly created thread in this process (process table discussion below)
		-assign current address space to this forked thread
		-call function Kernel_Thread(function pointer, virtual address of top of stack)
	else
		-error message
Kernel_Thread(function pointer, virtual address of top of stack)
	Write registers for the function and stack
	Restore the address space to load these
	Run the machine

To Exec a file:
SpaceId Exec_Syscall(char* name)
	Invoke fileSystem->Open() to open executable pointed to by name
	if(file descriptor is not NULL)
		-allocate new address space for this process
		-create a new thread for this process
		-set the address space just created to be the newly created thread's address space
		-update process table accordingly
		-delete file descriptor
		-Internal Nachos Fork to Exec_Thread
	else
		-error message
	return dummy value (spaceId used to provide each process with unique id; not needed for project 2 syscall implementations)

Exec_Thread()
	Initialize registers for this (the newly forked) thread
	Restore address space
	Run the machine

To exit a thread:
int Exit_Syscall(int status)
	if(thread is last userprog thread)
		-cleanup process table 
		-delete address space
		-call interrupt->Halt()
		-return 0 //0 = thread is last userprog thread

	else if(thread is last in its process but not last userprog thread)
		-remove thread entry from process table
		-remove process entry from process table
		-delete current address space
		-call thread->finish
		-return 1 //1 = thread is last in its process but not last userprog thread


	else //if thread is not last in process 
		-deallocate stack space
		-remove thread entry from process table
		-return 2// 2 = thread is not last in process


=================
V. Testing:  (For each test case, you must show)
=================
           + How to test
	
To run a test use the following command:
nachos -x ../test/[executable name]

Executable Names for Tests in the test directory:
testfork
testexec
testsynchmanager
testmultisim

Running the restaurant simulation multiple times:
		nachos -x ../test/testmultisim
By default, each simulation runs with 3 OrderTakers, 3 Waiters, and 20 Customers

           + Test Output

	Output for testfork:
		Press Ctrl-C once the threads are finished printing
Forking test1
Forking test2
Running test1
This will be printed 8 times (1)
This will be printed 8 times (2)
This will be printed 8 times (3)
This will be printed 8 times (4)
This will be printed 8 times (5)
This will be printed 8 times (6)
This will be printed 8 times (7)
This will be printed 8 times (8)
test1 complete
Running test2
This will be printed 4 times (1)
This will be printed 4 times (2)
This will be printed 4 times (3)
This will be printed 4 times (4)
test2 complete


Output for testexec:
	Press Ctrl-C once the threads are finished printing
Exec'ing exectestprogram1
hereintestexec
Exec'ing exectestprogram2
Running test1
This will be printed 8 times
This will be printed 8 times
This will be printed 8 times
This will be printed 8 times
This will be printed 8 times
This will be printed 8 times
This will be printed 8 times
This will be printed 8 times
test1 complete
Running test2
This will be printed 4 times
This will be printed 4 times
This will be printed 4 times
This will be printed 4 times
test2 complete



Output for testsynchmanager:

=== Test SyncManager ===
-TestCreateLock-
Creating Lock...
Index result: 0
Create 20 locks:
Index result: 1
Index result: 2
Index result: 3
Index result: 4
Index result: 5
Index result: 6
Index result: 7
Index result: 8
Index result: 9
Index result: 10
Index result: 11
Index result: 12
Index result: 13
Index result: 14
Index result: 15
Index result: 16
Index result: 17
Index result: 18
Index result: 19
Index result: 20
Create locks until the OS runs out:
ERROR: Cannot create lock
Error value: 10000
Test CreateLock Complete

-TestDestroyLock-
Create and Destory 1 lock
Index result: 0
Try to destory that lock a 2nd time:
ERROR: No Lock to destroy
DestoryLock on bad data:
ERROR: No Lock to destroy
Make 5 locks:
Index result: 0
Index result: 1
Index result: 2
Index result: 3
Index result: 4
Destroy 3 of them, then create 3 more:
Index result: 0
Index result: 1
Index result: 2
Index result: 3
Index result: 4
Results should be the same. Shows lock reuse:
Test DestroyLock Complete

-TestAquire-
Aquire bad data
ERROR: No Lock available to Acquire
Create lock and Aquire
Acquire lock a second time
Delete the lock while still acquired
Acquire lock a third time
Release lock to actually be deleted, then Acquire
ERROR: No Lock available to Acquire
TestAquire Completed

-TestRelease-
Release bad data
ERROR: No Lock available to Release
Create lock, Aquire and Release
Release lock a second time
Delete the lock and try to release
ERROR: No Lock available to Release
TestRelease Completed

-TestCreateCondition-
Creating CV...
Index result: 0
Create 20 CVs:
Index result: 1
Index result: 2
Index result: 3
Index result: 4
Index result: 5
Index result: 6
Index result: 7
Index result: 8
Index result: 9
Index result: 10
Index result: 11
Index result: 12
Index result: 13
Index result: 14
Index result: 15
Index result: 16
Index result: 17
Index result: 18
Index result: 19
Index result: 20
Create CVs until the OS runs out:
ERROR: Cannot create Condition
Error value: 10000
TestCreateCondition Completed

-TestDestroyCondition-
Create and Destory 1 CV
Index result: 0
Try to destory that CV a 2nd time:
DERROR: No Condition to destroy
DestroyCondition on bad data:
ERROR: No Condition to destroy
Make 5 CVs:
Index result: 0
Index result: 1
Index result: 2
Index result: 3
Index result: 4
Destroy 3 of them, then create 3 more:
Index result: 0
Index result: 1
Index result: 2
Index result: 3
Index result: 4
Results should be the same. Shows CV reuse:
TestDestroyCondition Completed

-TestWait-
Wait on Bad CV and Bad Lock
ERROR: No Condition to available for Wait
Wait on Good CV and Bad Lock
ERROR: No Lock available for Wait
Wait on Bad CV and Good Lock
ERROR: No Condition to available for Wait
Fork a helper thread
TestWait Waiting on Good CV and Good Lock
TestWaitHelper starting...
TestWaitHelper Signaling TestWait
TestWaitHelper waiting for Signal from TestWait
TestWait woke up, signaling TestWaitHelper
TestWaitHelper woke up
TestWaitHelper exiting...
Delete CV, then Wait
ERROR: No Condition to available for Wait
Make new CV, delete lock, then Wait
ERROR: No Lock available for Wait
Delete CV and Lock, then Wait
ERROR: No Condition to available for Wait
TestWait Completed

-TestSignal-
Signal Bad CV and Bad Lock
ERROR: No Condition to available for Signal
Signal Good CV and Bad Lock
ERROR: No Lock available for Signal
Signal Bad CV and Good Lock
ERROR: No Condition to available for Signal
Signal Good CV and Good Lock
Delete CV, then Signal
ERROR: No Condition to available for Signal
Make new CV, delete lock, then Signal
ERROR: No Lock available for Signal
Delete CV and Lock, then Signal
ERROR: No Condition to available for Signal
TestSignal Completed

-TestBroadcast-
Broadcast Bad CV and Bad Lock
ERROR: No Condition to available for Broadcast
Broadcast Good CV and Bad Lock
ERROR: No Lock available for Broadcast
Broadcast Bad CV and Good Lock
ERROR: No Condition to available for Broadcast
Broadcast Good CV and Good Lock
Delete CV, then Broadcast
ERROR: No Condition to available for Broadcast
Make new CV, delete lock, then Broadcast
ERROR: No Lock available for Broadcast
Delete CV and Lock, then Broadcast
ERROR: No Condition to available for Broadcast
TestBroadcast Completed

Output for testmultisim:
******** MULTI SIMULATION TEST ********

	“It prints so much, that I actually can’t paste it all.  Also that would be obnoxious, I don’t want to paste that.  Shit I forgot to test our RS values. I forgot about that” 
- Greg Lieberman on pasting the simulation output in our design document.



=================
VI. Discussion:
=================
           + Experiment expectation.  (What you hope will happen.)
We expected that this assignment would be relatively straightforward, and easy to unit test.
           + Experiment result.  (What actually happens.)
		We ran into several inexplicable snags that took a couple days to resolve. 
           + Explanation
                       Most of the problems were related to a lack of Yield() statements in parts of our code. What a pain, .

=================
VII. Miscellaneous:
=================

- Response From McDonalds
***
The following is a work of fiction. Characters, names, situations, events, and locations 	described in this assignment are purely the invention of the author's mind, or are used fictitiously. Any sort of resemblance to people - living or dead, names and locations is purely coincidental.
***

Once the simulation was complete and thoroughly tested, our group presented the simulation to our employers at McDonalds. As the McDonalds managers saw the lightning speed at which the Carls Jr. staff worked, they were completely in awe. They were so impressed by our simulation, that one of them suggested replacing their entire existing workforce with robots running our simulation. We are pretty excited about this, and will have a meeting about the workforce refactoring early next week.  
