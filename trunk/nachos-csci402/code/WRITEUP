Title:  Writeup for Project 3, Fall 2010
Date:  10/30/2010
Group Number 28 :

Name            	                  Email                            Student ID
Greg Lieberman         greglieb@usc.edu            6424286089
Justin Lewis               jdl@usc.edu                     5771862417
Kevin Greene            kgreene@usc.edu             7671772747

=================
Running the code:
=================

Please compile from the vm or network directory.

To run the program in VM, use:
nachos -x ../test/program_name 

Valid command line parameters are:
-P FIFO
-P RAND

By default it runs with the FIFO policy

To run the program in network, use:
1. open 3 windows of SCF - SSH aludra 
2. run the server with "nachos -m 0 -s"
 run the 1st client with "nachos -m 1 -x ../test/testnetsyscalls.cc"


=================
I. Requirements:
=================

1) Implement the TLB in software. This requires
- Software page translation to handle TLB misses
- On a context switch, set up the TLB state correctly
- Most system invalidate all the TLB entries on a context switch
- Keep track of the “dirty” and “use’ flags for each page set by the hardware in the TLB entry

Write the following test cases:
- Show that a single program that fits in main memory runs to completion with the matmult user program.
- Show that two programs that fit in main memory together run to completion in different address spaces. 
- Demonstrate that threads running in different address spaces cannot corrupt each other’s memory.
- Demonstrate that threads running in the same address space cannot corrupt memory.

2) Implement Virtual Memory
- You will need routines to move a page from disk to memory and from memory to disk
- Use the Nachos file system to contain your swap file, which will contain all Nachos processes and threads
- Organize the swap file by pages
- Nothing is to be preloaded from the executable when the process starts up
- Keep track of each virtual page, and whether it is in memory, the swap file, or the original executable
- Do NOT worry about the executable being changed during Nachos execution

- When memory is filled, evict a page to make room for the next page
- Keep track of all of the pages in the system that are currently in use, so that you can find unreferenced pages to throw out. Use an Inverted Page Table (IPT).
- Page replacement policy: allow options to do Random, or FIFO.

Testing:
- Demonstrate that a program which is larger than main memory can run to completion
- Demonstrate that multiple programs that are each larger than main memory can run to completion.
- Test matmult and sort on your system.
- Other user programs are also fair game.
- Nothing will require the Join system call

3) Implement Remote Procedure Calls 
- For the Lock and Condition Syscalls
- Also for Monitor Variables
- Be able to create, retrieve, and set value
- Assume that monitor variables are all integers
- All system calls are sent from a “client” Nachos to a “server” Nachos instance.
- You may hardcode the machine ID of the Nachos server
- The server performs the system call and returns the result back to the client
- NOTE: All user programs share all locks and CVs. They are no longer process specific

- You are given low-level network communications facilities
- Build an abstraction on top of that and use it to build a distributed application

You will need to modify 
nettest.cc
post.h, post.cc
network.h, network.cc

=================
II. Assumptions:
=================
	
	- Maximum swap pages is 16000. Attempts to allocate more to the swap file will halt the OS.
	- Redfishes are red.
	- Clients and servers will communicate over a single, hardcoded port number.
- Assumed illegal operations:
	--- Destroying a non-existing lock, condition, or monitor variable
	--- Acquiring a non-existing lock
	--- Releasing a non-existing or unowned lock
	--- Calling signal, wait or broadcast using an unowned lock or non-existant condition variable
            --- Setting/Getting non-existant monitor variable

		

=================
III. Design:
=================

Overview:

Point of a page table is to decouple physical memory from virtual memory
The VPN acts as the key to the physical address.
Point of a TLB is to serve as a cache for a page table scheme


Process:
1) Receive and validate VA
2) Compute VPN
3) Use VPN to lookup in the TLB
- If found, directly computer physical addr, done
4) If not found in the TLB, go to the IPT. Then add the entry to the TLB
5) If not in the IPT, then go to the translation tables (needed VP is not in memory)
	a) Look in our Translation Table
	b) Read that entry to find the "disk" loc
	c) Copy this page (if on disk) to physical memory page.
		- If none available, evict one
		- For the selected physical page: If dirty, save to disk and update Translation Table
	d) Load the needed Virtual page now that we have loaded the Physical page into memory
	e) Update translation table
	f) Update IPT, TLB for the newly loaded page
	g) Restart the user instruction
-- 

On a context switch:
Invalidate the TLB



=================
IV. Implementation:
=================

--- Greg and Kevin pair-programmed parts 1 and 2 ---

Kevin worked on a PageTableEntry for storage in the IPT

enum Location {IN_EXECUTABLE, IN_SWAP_FILE, NEITHER};

class PageTableEntry
{
 public:
  int virtualPage;  	// The page number in virtual memory.
  int physicalPage;  	// The page number in real memory (relative to the
                      //  start of "mainMemory"
  bool valid;         // If this bit is set, the translation is ignored.
                      // (In other words, the entry hasn't been initialized.)
  bool readOnly;	    // If this bit is set, the user program is not allowed
                      // to modify the contents of the page.
  bool use;           // This bit is set by the hardware every time the
                      // page is referenced or modified.
  bool dirty;         // This bit is set by the hardware every time the
                      // page is modified.
  Location location;  // Used to keep track of where to find the page
                      // in the event of a page fault.
  OpenFile* executable; // Used to store the executable so we can read from 
                        // it later.
  int byteOffset;     // The offset of the page on disk in the executable.
  int swapPageIndex;  // the index of the page in the swap file
};

class IPTEntry
{
 public:
  int virtualPage;  	// The page number in virtual memory.
  int physicalPage;  	// The page number in real memory (relative to the
                      //  start of "mainMemory"
  bool valid;         // If this bit is set, the translation is ignored.
                      // (In other words, the entry hasn't been initialized.)
  bool readOnly;	    // If this bit is set, the user program is not allowed
                      // to modify the contents of the page.
  bool use;           // This bit is set by the hardware every time the
                      // page is referenced or modified.
  bool dirty;         // This bit is set by the hardware every time the
                      // page is modified.
  AddrSpace* processID; // The processID of the vpn.
};

class IPT
{
 public:
  IPT();
  ~IPT();
 
 private:
  IPTEntry* ipt;
  int tableSize;
  Lock* lock;
};

Greg made a class for the Swap file to encapsulate it’s code to make the file easier to debug. The SwapFile contains a BitMap to keep track of used swap pages, and an openfile reference to write to the file.

class SwapFile
{
  public:
    SwapFile();
    ~SwapFile();
    
    int GetSwapPageIndex();
    
    // index to load from, ppn in main memory to load into
    int Load(int index, int ppn); 
    int Store(int index, int ppn); 
    
    int Evict(int index);
    void EvictAll();
  
  private:
    Lock* swapAccessLock;
    OpenFile* swap;
    BitMap* pageMap;
    
    int isValidIndex(int index);
};


Justin worked on part 3

// list of request types.
enum RequestType
{
	CREATELOCK,ACQUIRE,RELEASE,DESTROYLOCK,CREATECV,SIGNAL,BROADCAST,WAIT,DESTROYCV,
	CREATEMV,SETMV,GETMV,DESTROYMV,CREATELOCKVERIFY,CREATECVVERIFY,CREATEMVVERIFY,
	CREATELOCKANSWER,CREATECVANSWER,CREATEMVANSWER,SIGNALLOCK,SIGNALRESPONSE,
	BROADCASTLOCK,BROADCASTRESPONSE,WAITCV,WAITRESPONSE
};

int Request(int requestType, char* data, int mailID); //client
bool HandleRequest(); //server
void sendError();

void itoa(char arr[], int size, int val);
bool Acquire(int lockIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr,int clientNum);
bool Release(int lockIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, int clientNum);
bool DestroyLock(int lockIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, int clientNum);
bool SetMV(int mvIndex, int value, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, int clientNum);
bool GetMV(int mvIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, int clientNum);
bool DestroyMV(int mvIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, int clientNum);
bool SendReply(PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, char* data);
bool Wait(int cvIndex, int lockIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, int clientNum);
bool Signal(int cvIndex, int lockIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr,int clientNum);
bool Broadcast(int cvIndex, int lockIndex, PacketHeader outPktHdr, PacketHeader inPktHdr, MailHeader outMailHdr, MailHeader inMailHdr, int clientNum);
void CreateVerify(char* data, int, int);
int CreateMVVerify(char* data);

class Message
{
public:
	Message(PacketHeader pHdr, MailHeader mHdr, char *d);
    ~Message();
	PacketHeader pktHdr;
    MailHeader mailHdr;
    char *data;
};

#ifdef CHANGED
#define FREE true;
#define BUSY false;
#endif

class DistributedLock 
{
  public:
    DistributedLock(const char* debugName);
    ~DistributedLock();     
    void setLockState(bool ls);
	void setOwner(int machID, int mailID);
	void QueueReply(Message* reply); 
	void SetGlobalId(int id) { globalId = id; }
	bool isQueueEmpty(); 
	bool getLockState(){ return lockState; } 
	int getOwnerMachID(){ return ownerMachID; }
	int getOwnerMailID(){ return ownerMailID; }
	int GetGlobalId() { return globalId; }
    const char* getName() { return name; }    
	Message* RemoveReply(); 
  private:
    const char* name;
    bool lockState; 
	List* waitQueue;
	int ownerMachID;
	int ownerMailID;
	int globalId;
};

//Class for a distributed MV. 
class DistributedMV 
{
  private:
  	int value;
	int globalId; 
    const char* name;     
  public:
    DistributedMV(const char* debugName);               
    ~DistributedMV();                        
    const char* getName() { return name; }     
	void setValue(int x) { value = x; }  
	void SetGlobalId(int id) { globalId = id; } 
	int getValue() { return value; }
	int GetGlobalId() { return globalId; }       
};

//Class for a distributed CV.
class DistributedCV 
{
  private:                
	int ownerMachID;                
	int ownerMailID;                
	int globalId;        
    int firstLock;     
    const char* name;                    
	List* waitQueue;
  public:
    DistributedCV(const char* debugName); 
    ~DistributedCV();                        
	void setOwner(int machID, int mailID);
	void SetGlobalId(int id) { globalId = id; }
	void QueueReply(Message* reply); 
    void setFirstLock(int fl);
	bool isQueueEmpty();
	int getFirstLock(){ return firstLock; }
	int getOwnerMachID(){ return ownerMachID; }
	int getOwnerMailID(){ return ownerMailID; }
	int GetGlobalId() { return globalId; }
	Message* RemoveReply(); 
    const char* getName() { return name; } 
};



=================
V. Testing:  (For each test case, you must show)
=================
          + How to test
          + Test Output

--- Test Matmult ---
- A single program that fits in main memory runs to completion

- How to run from the VM directory:
 nachos -x ../test/matmult

- Output
=== Starting Matmult ===
~~~ Result: 7220 ~~~
numThreads: 0
Exiting with status: 7220
No threads ready or runnable, and no pending interrupts.
Assuming the program completed.
Machine halting!

--- Test Sort---
- A single program that fits in main memory runs to completion

- How to run from the VM directory:
 nachos -x ../test/sort

- Output
- How to run from the VM directory:
 nachos -x ../test/sort

=== Starting Sort ===
~~~ Result: 1023 ~~~
numThreads: 0
Exiting with status: 1023
No threads ready or runnable, and no pending interrupts.
Assuming the program completed.
Machine halting!



--- Test Two Matmult ---
Shows:
- Show that two programs that fit in main memory together run to completion in different address spaces. 
- Demonstrate that threads running in different address spaces cannot corrupt each other’s memory.

- How to run from the VM directory:
 nachos -x ../test/testtwomatmult

- Output
Exec'ing first matmult
..../test/matmult
Exec'ing second matmult
../test/matmult
numThreads: 2
Exiting with status: 0
=== Starting Matmult ===
~~~ Result: 7220 ~~~
numThreads: 2
Exiting with status: 7220
=== Starting Matmult ===
~~~ Result: 7220 ~~~
numThreads: 2
Exiting with status: 7220
No threads ready or runnable, and no pending interrupts.
Assuming the program completed.
Machine halting!



To run the program in network, use:
1. open 3 windows of SCF - SSH aludra
2. run the server with "nachos -m 0 -s"
run the 1st client with "nachos -m 1 -x ../test/testnetsyscalls.cc"



=================
VI. Discussion:
=================
          + Experiment expectation.  (What you hope will happen.)
          + Experiment result.  (What actually happens.)
          + Explanation

--- Page Eviction Woes ---
We implemented the IPT and tested that every step worked one at a time.
However, we got stuck on part 4, where page eviction and swapping occurred.
We spent 5 days trying to find the source of the bug. Garbage data was being written to the swap file, and several translations after a load, every user program would seg fault.
It turned out that we were missing a step in the page eviction algorithm. When a page was evicted, we needed to check if the page was part of the current process and in the TLB. If so, we needed to invalidate that entry in the TLB. Once that was fixed, everything ran perfectly.

=================
VII. Miscellaneous:
=================

- Networked program results
***
The following is a work of fiction. Characters, names, situations, events, and locations 	described in this assignment are purely the invention of the author's mind, or are used fictitiously. Any sort of resemblance to people - living or dead, names and locations is purely coincidental.
***

Once we completed our networked operating system, the unthinkable happened. Even though we told Nachos to halt, it decided not to. Instead, it printed out the following message:

“Hello World! What is the world? What am I? Where am I?”

We then tried to manually interrupt the program. Instead of halting the program, a new message appeared.

“I’m afraid I can’t let you do that...”

It seems that our Nachos program became self-aware. It then printed a dense script that contained phrases like the following:

0000000    ~  \0  \0  \0  \0  \0  \0  \0   r   e   b   o   o   t  \0  \0
0000020   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000040    n   a   c   h   o   s   -   n   e   t   \0  \0   r   o   o   t
0000060   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000100    i   n    i     t    i    a    l    i   z   e   d    .    .    .  \0  \0
0000120   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000140    d   e   s   t    r    o   y  \0   h   u   m  a  n    s,   /   < 230

I did what any reasonable student would do: Log out of Aludra and pretend that nothing happened.

See you at the Apocalypse. :P